/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 
 Given binary tree [3,9,20,null,null,15,7],
     3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]

 */
class BFSSolution {
    public List<List<Integer>> levelOrder(TreeNode root) {
/*1)This is to store the result - each item in list is a list so we have o/p as List of List
  2)Check if the root is null to do error handling
  3)For doing BFS we need to follow a standard process of using Queue data structure i.e. a First Come First Serve DS(eg: Restuarant Queue). 4)We need to add all the elements to the queue, so now if we get root is not null from second step we will add the root to the queue
  and then we need to check other elements so we will apply a while loop 4) we will calculate the size of the queue to know how many elements we have at each level.
  5)We need to create another list to store elements from each level
  further we will gather the elements from each level by traversing over queue using for loop and then extracting current node using remove() method. Once we get the value(data) we will add it to the list which we are using to collect elements from each level
  6)Then we will further look whether the current node has left or right child if the current.left != null then we will add current.left and similarly right to check in subsequent iteration.
  
  
  */
        List<List<Integer>> result = new ArrayList<>();
        
        if(root==null){
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> currentLevel = new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode current = queue.remove();
                currentLevel.add(current.val);
                if(current.left!=null){
                    queue.add(current.left);
                }
                if(current.right!=null){
                    queue.add(current.right);
                }
            }
            result.add(currentLevel);
            }
    
    return result;
        
    }
}
